import { Readable, Writable } from 'stream';
import { assert, checkType, isObject } from '../../shared/utils';
export { getNodeStream };
export { getWebStream };
export { pipeToStreamWritableNode };
export { pipeToStreamWritableWeb };
export { isStreamReadableWeb };
export { isStreamReadableNode };
export { streamReadableNodeToString };
export { streamReadableWebToString };
export { streamPipeWebToString };
export { streamPipeNodeToString };
export { addStringWrapperToStream };
export { isStream };
export { streamToString };
// Public
export { pipeWebStream };
export { pipeNodeStream };
function isStreamReadableWeb(thing) {
    return typeof ReadableStream !== 'undefined' && thing instanceof ReadableStream;
}
function isStreamReadableNode(thing) {
    return thing instanceof Readable;
}
async function streamReadableNodeToString(readableNode) {
    // Copied from: https://stackoverflow.com/questions/10623798/how-do-i-read-the-contents-of-a-node-js-stream-into-a-string-variable/49428486#49428486
    const chunks = [];
    return new Promise((resolve, reject) => {
        readableNode.on('data', (chunk) => chunks.push(Buffer.from(chunk)));
        readableNode.on('error', (err) => reject(err));
        readableNode.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
    });
}
async function streamReadableWebToString(readableWeb) {
    let str = '';
    const reader = readableWeb.getReader();
    while (true) {
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        str += value;
    }
    return str;
}
function stringToStreamReadableNode(str) {
    return Readable.from(str);
}
function stringToStreamReadableWeb(str) {
    // `ReadableStream.from()` spec discussion: https://github.com/whatwg/streams/issues/1018
    const readableStream = new ReadableStream({
        start(controller) {
            controller.enqueue(str);
            controller.close();
        }
    });
    return readableStream;
}
function stringToStreamPipeNode(str) {
    return (writable) => {
        writable.write(str);
        writable.end();
    };
}
function stringToStreamPipeWeb(str) {
    return (writable) => {
        const writer = writable.getWriter();
        const encoder = new TextEncoder();
        writer.write(encoder.encode(str));
        writer.close();
    };
}
function streamPipeNodeToString(streamPipeNode) {
    let str = '';
    let resolve;
    const promise = new Promise((r) => (resolve = r));
    const writable = new Writable({
        write(chunk, encoding, callback) {
            assert(encoding === 'utf8');
            const s = chunk.toString();
            assert(typeof s === 'string');
            str += s;
            callback();
        },
        final(callback) {
            resolve(str);
            callback();
        }
    });
    streamPipeNode(writable);
    return promise;
}
function streamPipeWebToString(streamPipeWeb) {
    let str = '';
    let resolve;
    const promise = new Promise((r) => (resolve = r));
    const writable = new WritableStream({
        write(chunk) {
            assert(typeof chunk === 'string');
            str += chunk;
        },
        close() {
            resolve(str);
        }
    });
    streamPipeWeb(writable);
    return promise;
}
function getNodeStream(escapeResult) {
    if (typeof escapeResult === 'string') {
        return stringToStreamReadableNode(escapeResult);
    }
    if (isStreamReadableNode(escapeResult)) {
        return escapeResult;
    }
    return null;
}
function getWebStream(escapeResult) {
    if (typeof escapeResult === 'string') {
        return stringToStreamReadableWeb(escapeResult);
    }
    if (isStreamReadableWeb(escapeResult)) {
        return escapeResult;
    }
    return null;
}
function pipeToStreamWritableWeb(escapeResult, writable) {
    if (typeof escapeResult === 'string') {
        const streamPipeWeb = stringToStreamPipeWeb(escapeResult);
        streamPipeWeb(writable);
        return true;
    }
    const streamPipeWeb = getStreamPipeWeb(escapeResult);
    if (streamPipeWeb === null) {
        return false;
    }
    streamPipeWeb(writable);
    return true;
}
function pipeToStreamWritableNode(escapeResult, writable) {
    if (typeof escapeResult === 'string') {
        const streamPipeNode = stringToStreamPipeNode(escapeResult);
        streamPipeNode(writable);
        return true;
    }
    const streamPipeNode = getStreamPipeNode(escapeResult);
    if (streamPipeNode === null) {
        return false;
    }
    streamPipeNode(writable);
    return true;
}
f(1);
function f(a) {
    if (typeof a === 'number') {
        return 2;
    }
    return a;
}
function addStringWrapperToStream(stream, stringBegin, stringEnd) {
    if (isStreamPipeNode(stream)) {
        return pipeNodeStream((writable) => {
            writable.write(stringBegin);
            const writableProxy = new Writable({
                write(chunk, _encoding, callback) {
                    writable.write(chunk);
                    callback();
                },
                final(callback) {
                    writable.write(stringEnd);
                    writable.end();
                    callback();
                }
            });
            const streamPipeNode = getStreamPipeNode(stream);
            streamPipeNode(writableProxy);
        });
    }
    if (isStreamPipeWeb(stream)) {
        return pipeWebStream((writable) => {
            const writer = writable.getWriter();
            writer.write(stringBegin);
            const writableProxy = new WritableStream({
                write(chunk) {
                    writer.write(chunk);
                },
                close() {
                    writer.write(stringEnd);
                    writer.close();
                }
            });
            const streamPipeWeb = getStreamPipeWeb(stream);
            streamPipeWeb(writableProxy);
        });
    }
    if (isStreamReadableWeb(stream)) {
        return new ReadableStream({
            async start(controller) {
                controller.enqueue(stringBegin);
                const readableWeb = stream;
                const reader = readableWeb.getReader();
                while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                        break;
                    }
                    controller.enqueue(value);
                }
                controller.enqueue(stringEnd);
                controller.close();
            }
        });
    }
    if (isStreamReadableNode(stream)) {
        const readableNodeProxy = new Readable({ read() { } });
        readableNodeProxy.push(stringBegin);
        const readableNode = stream;
        readableNode.on('data', (chunk) => readableNodeProxy.push(chunk));
        readableNode.on('error', (err) => readableNodeProxy.destroy(err));
        readableNode.on('end', () => {
            readableNodeProxy.push(stringEnd);
            readableNodeProxy.push(null);
        });
        return readableNodeProxy;
    }
    assert(false);
}
function isStream(something) {
    if (isStreamReadableWeb(something) ||
        isStreamReadableNode(something) ||
        isStreamPipeNode(something) ||
        isStreamPipeWeb(something)) {
        checkType(something);
        return true;
    }
    return false;
}
const __streamPipeWeb = Symbol('__streamPipeWeb');
function pipeWebStream(pipe) {
    return { [__streamPipeWeb]: pipe };
}
function getStreamPipeWeb(thing) {
    if (isStreamPipeWeb(thing)) {
        return thing[__streamPipeWeb];
    }
    return null;
}
function isStreamPipeWeb(something) {
    return isObject(something) && __streamPipeWeb in something;
}
const __streamPipeNode = Symbol('__streamPipeNode');
function pipeNodeStream(pipe) {
    return { [__streamPipeNode]: pipe };
}
function getStreamPipeNode(thing) {
    if (isStreamPipeNode(thing)) {
        return thing[__streamPipeNode];
    }
    return null;
}
function isStreamPipeNode(something) {
    return isObject(something) && __streamPipeNode in something;
}
async function streamToString(escapeResult) {
    if (isStreamReadableWeb(escapeResult)) {
        return await streamReadableWebToString(escapeResult);
    }
    if (isStreamReadableNode(escapeResult)) {
        return await streamReadableNodeToString(escapeResult);
    }
    if (isStreamPipeNode(escapeResult)) {
        return streamPipeNodeToString(getStreamPipeNode(escapeResult));
    }
    if (isStreamPipeWeb(escapeResult)) {
        return streamPipeWebToString(getStreamPipeWeb(escapeResult));
    }
    checkType(escapeResult);
    assert(false);
}
//# sourceMappingURL=stream.js.map