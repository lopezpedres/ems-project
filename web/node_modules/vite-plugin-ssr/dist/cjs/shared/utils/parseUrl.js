"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUrlFullWithoutHash = exports.getUrlParts = exports.getUrlParsed = exports.getUrlPathname = exports.getUrlFull = exports.addUrlOrigin = exports.handleUrlOrigin = void 0;
const assert_1 = require("./assert");
const slice_1 = require("./slice");
function handleUrlOrigin(url) {
    (0, assert_1.assert)(url.startsWith('/') || url.startsWith('http'));
    if (url.startsWith('/')) {
        return { urlWithoutOrigin: url, urlOrigin: null };
    }
    else {
        const urlOrigin = parseWithNewUrl(url).origin;
        (0, assert_1.assert)(urlOrigin !== '', { url });
        (0, assert_1.assert)(urlOrigin.startsWith('http'), { url });
        (0, assert_1.assert)(url.startsWith(urlOrigin), { url });
        const urlWithoutOrigin = url.slice(urlOrigin.length);
        (0, assert_1.assert)(`${urlOrigin}${urlWithoutOrigin}` === url, { url });
        (0, assert_1.assert)(urlWithoutOrigin.startsWith('/'), { url });
        return { urlWithoutOrigin, urlOrigin };
    }
}
exports.handleUrlOrigin = handleUrlOrigin;
function addUrlOrigin(url, urlOrigin) {
    (0, assert_1.assert)(urlOrigin.startsWith('http'), { url, urlOrigin });
    if (urlOrigin.endsWith('/')) {
        urlOrigin = (0, slice_1.slice)(urlOrigin, 0, -1);
    }
    (0, assert_1.assert)(!urlOrigin.endsWith('/'), { url, urlOrigin });
    (0, assert_1.assert)(url.startsWith('/'), { url, urlOrigin });
    return `${urlOrigin}${url}`;
}
exports.addUrlOrigin = addUrlOrigin;
/**
 Returns `${pathname}${search}${hash}`. (Basically removes the origin.)
*/
function getUrlFull(url) {
    url = retrieveUrl(url);
    return handleUrlOrigin(url).urlWithoutOrigin;
}
exports.getUrlFull = getUrlFull;
/**
 Returns `${pathname}`
*/
function getUrlPathname(url) {
    url = retrieveUrl(url);
    const { pathname } = parseWithNewUrl(url);
    const urlPathname = pathname;
    return urlPathname;
}
exports.getUrlPathname = getUrlPathname;
function getUrlParts(url) {
    url = retrieveUrl(url);
    const [urlWithoutHash, ...hashList] = url.split('#');
    (0, assert_1.assert)(urlWithoutHash);
    const hashString = ['', ...hashList].join('#');
    const [urlWithoutSearch, ...searchList] = urlWithoutHash.split('?');
    (0, assert_1.assert)(urlWithoutSearch);
    const searchString = ['', ...searchList].join('?');
    const { origin, pathname: pathnameFromNewUrl } = parseWithNewUrl(urlWithoutSearch);
    (0, assert_1.assert)(url.startsWith(origin), { url });
    const pathname = urlWithoutSearch.slice(origin.length);
    (0, assert_1.assert)(pathname === pathnameFromNewUrl, { url });
    const urlRecreated = `${origin}${pathname}${searchString}${hashString}`;
    (0, assert_1.assert)(url === urlRecreated, { urlRecreated, url });
    return { origin, pathname, searchString, hashString };
}
exports.getUrlParts = getUrlParts;
function getUrlParsed(url) {
    url = retrieveUrl(url);
    const { origin, pathname, searchString, hashString } = getUrlParts(url);
    (0, assert_1.assert)(searchString === '' || searchString.startsWith('?'));
    const search = searchString === '' ? null : Object.fromEntries([...new URLSearchParams(searchString)]);
    (0, assert_1.assert)(hashString === '' || hashString.startsWith('#'));
    const hash = hashString === '' ? null : decodeURIComponent(hashString.slice(1));
    (0, assert_1.assert)(pathname.startsWith('/'));
    (0, assert_1.assert)(url.startsWith(`${origin}${pathname}`));
    return { origin, pathname, search, hash };
}
exports.getUrlParsed = getUrlParsed;
function getUrlFullWithoutHash(url) {
    const urlFull = getUrlFull(url);
    const urlFullWithoutHash = urlFull.split('#')[0];
    (0, assert_1.assert)(urlFullWithoutHash);
    return urlFullWithoutHash;
}
exports.getUrlFullWithoutHash = getUrlFullWithoutHash;
function retrieveUrl(url) {
    if (!url) {
        url = window.location.href;
    }
    return url;
}
function parseWithNewUrl(url) {
    try {
        const { origin, pathname } = new URL(url);
        return { origin, pathname };
    }
    catch (err) {
        (0, assert_1.assert)(url.startsWith('/'), { url });
        const { pathname } = new URL('http://fake-origin.example.org' + url);
        return { origin: '', pathname };
    }
}
/* Tempting to also apply `cleanUrl()` on `pageContext.urlNormalized` but AFAICT no one needs this; `pageContext.urlParsed` is enough.
 *
function cleanUrl(url: string): string {
  return getUrlFromParsed(getUrlParsed(url))
}

function getUrlFromParsed(urlParsed: UrlParsed): string {
  const { origin, pathname, search, hash } = urlParsed

  const searchParams = new URLSearchParams('')
  assert(Array.from(searchParams.keys()).length === 0)
  Object.entries(search || {}).forEach(([key, val]) => {
    searchParams.set(key, val)
  })
  const searchString = searchParams.toString()

  assert(hash === null || !hash.startsWith('#'))
  const hashString = hash === null ? '' : '#' + hash

  assert(origin === '' || origin.startsWith('http'))
  assert(pathname.startsWith('/'))
  assert(searchString === '' || searchString.startsWith('?'))
  assert(hashString === '' || hashString.startsWith('#'))
  return `${origin}${pathname}${searchString}${hashString}`
}
*
*/
//# sourceMappingURL=parseUrl.js.map