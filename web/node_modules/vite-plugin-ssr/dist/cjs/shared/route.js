"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isStaticRoute = exports.isErrorPage = exports.getErrorPageId = exports.getAllPageIds = exports.loadPageRoutes = exports.route = void 0;
const getPageFiles_1 = require("./getPageFiles");
const utils_1 = require("./utils");
const renderPage_1 = require("../node/renderPage");
// @ts-ignore
const pathToRegexp = require("@brillout/path-to-regexp");
async function route(pageContext) {
    (0, renderPage_1.addComputedUrlProps)(pageContext);
    const pageContextAddendum = {};
    const pageContextAddendumHook = await callOnBeforeRouteHook(pageContext);
    if (pageContextAddendumHook !== null) {
        (0, utils_1.objectAssign)(pageContextAddendum, pageContextAddendumHook);
        if ((0, utils_1.hasProp)(pageContextAddendum, '_pageId', 'string') || (0, utils_1.hasProp)(pageContextAddendum, '_pageId', 'null')) {
            // We bypass `vite-plugin-ssr`'s routing
            return Object.assign(Object.assign({}, pageContextAddendum), { routeParams: pageContextAddendum.routeParams || {} });
        }
        // We already assign so that `pageContext.url === pageContextAddendum.url`; enabling the `onBeforeRoute()` hook to mutate `pageContext.url` before routing.
        (0, utils_1.objectAssign)(pageContext, pageContextAddendum);
    }
    // `vite-plugin-ssr`'s routing
    const allPageIds = pageContext._allPageIds;
    (0, utils_1.assert)(allPageIds.length >= 0);
    (0, utils_1.assertUsage)(allPageIds.length > 0, 'No `*.page.js` file found. You must create a `*.page.js` file, e.g. `pages/index.page.js` (or `pages/index.page.{jsx, tsx, vue, ...}`).');
    const { urlPathname } = pageContext;
    (0, utils_1.assert)(urlPathname.startsWith('/'));
    const routeResults = await Promise.all(pageContext._pageRoutes.map(async (pageRoute) => {
        const { pageId, filesystemRoute, pageRouteFile } = pageRoute;
        (0, utils_1.assertUsage)(!isReservedPageId(pageId), "Only `_default.page.*` and `_error.page.*` files are allowed to include the special character `_` in their path. The following shouldn't include `_`: " +
            pageId);
        if (pageRouteFile) {
            const pageRouteFileExports = pageRouteFile.fileExports;
            const pageRouteFilePath = pageRouteFile.filePath;
            // Route with Route String defined in `.page.route.js`
            if ((0, utils_1.hasProp)(pageRouteFileExports, 'default', 'string')) {
                const { matchValue, routeParams } = resolveRouteString(pageRouteFileExports, urlPathname, pageRouteFilePath);
                return { pageId, matchValue, routeParams };
            }
            // Route with Route Function defined in `.page.route.js`
            if ((0, utils_1.hasProp)(pageRouteFileExports, 'default', 'function')) {
                const { matchValue, routeParams } = await resolveRouteFunction(pageRouteFileExports, urlPathname, pageContext, pageRouteFilePath);
                return { pageId, matchValue, routeParams };
            }
            (0, utils_1.assert)(false);
        }
        const { matchValue, routeParams } = routeWith_filesystem(urlPathname, filesystemRoute);
        return { pageId, matchValue, routeParams };
    }));
    const winner = pickWinner(routeResults);
    // console.log('[Route Match]:', `[${urlPathname}]: ${winner && winner.pageId}`)
    if (!winner)
        return { _pageId: null, routeParams: {} };
    const { pageId, routeParams } = winner;
    (0, utils_1.assert)((0, utils_1.isPlainObject)(routeParams));
    (0, utils_1.objectAssign)(pageContextAddendum, {
        _pageId: pageId,
        routeParams
    });
    return pageContextAddendum;
}
exports.route = route;
async function callOnBeforeRouteHook(pageContext) {
    if (!pageContext._onBeforeRouteHook) {
        return null;
    }
    const result = await pageContext._onBeforeRouteHook.onBeforeRoute(pageContext);
    const errPrefix = `The \`onBeforeRoute()\` hook exported by ${pageContext._onBeforeRouteHook.filePath}`;
    (0, utils_1.assertUsage)(result === null ||
        result === undefined ||
        ((0, utils_1.isObjectWithKeys)(result, ['pageContext']) && (0, utils_1.hasProp)(result, 'pageContext')), `${errPrefix} should return \`null\`, \`undefined\`, or a plain JavaScript object \`{ pageContext: { /* ... */ } }\`.`);
    if (result === null || result === undefined) {
        return null;
    }
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(result, 'pageContext', 'object'), `${errPrefix} returned \`{ pageContext }\` but \`pageContext\` should be a plain JavaScript object.`);
    if ((0, utils_1.hasProp)(result.pageContext, '_pageId') && !(0, utils_1.hasProp)(result.pageContext, '_pageId', 'null')) {
        const errPrefix2 = `${errPrefix} returned \`{ pageContext: { _pageId } }\` but \`_pageId\` should be`;
        (0, utils_1.assertUsage)((0, utils_1.hasProp)(result.pageContext, '_pageId', 'string'), `${errPrefix2} a string or \`null\``);
        (0, utils_1.assertUsage)(pageContext._allPageIds.includes(result.pageContext._pageId), `${errPrefix2} one of following values: \`[${pageContext._allPageIds.map((s) => `'${s}'`).join(', ')}]\`.`);
    }
    if ((0, utils_1.hasProp)(result.pageContext, 'routeParams')) {
        assertRouteParams(result.pageContext, `${errPrefix} returned \`{ pageContext: { routeParams } }\` but \`routeParams\` should`);
    }
    return result.pageContext;
}
function getErrorPageId(allPageIds) {
    const errorPageIds = allPageIds.filter((pageId) => isErrorPage(pageId));
    (0, utils_1.assertUsage)(errorPageIds.length <= 1, `Only one \`_error.page.js\` is allowed. Found several: ${errorPageIds.join(' ')}`);
    if (errorPageIds.length > 0) {
        const errorPageId = errorPageIds[0];
        (0, utils_1.assert)(errorPageId);
        return errorPageId;
    }
    return null;
}
exports.getErrorPageId = getErrorPageId;
function pickWinner(routeResults) {
    const candidates = routeResults
        .filter(({ matchValue }) => matchValue !== false)
        .sort((0, utils_1.higherFirst)(({ matchValue }) => {
        (0, utils_1.assert)(matchValue !== false);
        return matchValue === true ? 0 : matchValue;
    }));
    const winner = candidates[0];
    return winner;
}
function routeWith_pathToRegexp(urlPathname, routeString) {
    const match = pathToRegexp(urlPathname, { path: routeString, exact: true });
    if (!match) {
        return { matchValue: false, routeParams: {} };
    }
    // The longer the route string, the more likely is it specific
    const matchValue = routeString.length;
    const routeParams = match.params || {};
    (0, utils_1.assert)((0, utils_1.isPlainObject)(routeParams));
    return { matchValue, routeParams };
}
function isStaticRoute(route) {
    const { matchValue, routeParams } = routeWith_pathToRegexp(route, route);
    return matchValue !== false && Object.keys(routeParams).length === 0;
}
exports.isStaticRoute = isStaticRoute;
function routeWith_filesystem(urlPathname, filesystemRoute) {
    urlPathname = removeTrailingSlash(urlPathname);
    // console.log('[Route Candidate] url:' + urlPathname, 'filesystemRoute:' + filesystemRoute)
    (0, utils_1.assert)(urlPathname.startsWith('/'));
    (0, utils_1.assert)(filesystemRoute.startsWith('/'));
    (0, utils_1.assert)(!urlPathname.endsWith('/') || urlPathname === '/');
    (0, utils_1.assert)(!filesystemRoute.endsWith('/') || filesystemRoute === '/');
    const matchValue = urlPathname === filesystemRoute;
    return { matchValue, routeParams: {} };
}
function removeTrailingSlash(url) {
    if (url === '/' || !url.endsWith('/')) {
        return url;
    }
    else {
        return (0, utils_1.slice)(url, 0, -1);
    }
}
function getFilesystemRoute(pageId, filesystemRoots) {
    // Handle Filesystem Routing Root
    const filesystemRootsMatch = filesystemRoots
        .filter(({ rootPath }) => pageId.startsWith(rootPath))
        .sort((0, utils_1.higherFirst)(({ rootPath }) => rootPath.length));
    const root = filesystemRootsMatch[0];
    let pageRoute = pageId;
    if (root) {
        const { rootPath, rootValue } = root;
        (0, utils_1.assert)(pageRoute.startsWith(rootPath));
        pageRoute = (0, utils_1.slice)(pageRoute, rootPath.length, 0);
        (0, utils_1.assert)(pageRoute.startsWith('/'));
        pageRoute = rootValue + (rootValue.endsWith('/') ? '' : '/') + (0, utils_1.slice)(pageRoute, 1, 0);
    }
    // Remove `pages/`, `index/, and `src/`, directories
    pageRoute = pageRoute.split('/pages/').join('/');
    pageRoute = pageRoute.split('/src/').join('/');
    pageRoute = pageRoute.split('/index/').join('/');
    // Hanlde `/index.page.*` suffix
    (0, utils_1.assert)(!pageRoute.includes('.page.'));
    if (pageRoute.endsWith('/index')) {
        pageRoute = (0, utils_1.slice)(pageRoute, 0, -'/index'.length);
    }
    if (pageRoute === '') {
        pageRoute = '/';
    }
    (0, utils_1.assert)(pageRoute.startsWith('/'));
    return pageRoute;
}
/**
  Returns the ID of all pages including `_error.page.*` but excluding `_default.page.*`.
*/
async function getAllPageIds(allPageFiles) {
    const pageFileIds = computePageIds(allPageFiles['.page']);
    const pageClientFileIds = computePageIds(allPageFiles['.page.client']);
    const pageServerFileIds = computePageIds(allPageFiles['.page.server']);
    const allPageIds = unique([...pageFileIds, ...pageClientFileIds, ...pageServerFileIds]);
    allPageIds.forEach((pageId) => {
        (0, utils_1.assertUsage)(pageFileIds.includes(pageId) || pageServerFileIds.includes(pageId), `File missing. You need to create at least \`${pageId}.page.server.js\` or \`${pageId}.page.js\`.`);
        (0, utils_1.assertUsage)(pageFileIds.includes(pageId) || pageClientFileIds.includes(pageId), `File missing. You need to create at least \`${pageId}.page.client.js\` or \`${pageId}.page.js\`.`);
    });
    return allPageIds;
}
exports.getAllPageIds = getAllPageIds;
function computePageIds(pageFiles) {
    const fileIds = pageFiles
        .map(({ filePath }) => filePath)
        .filter((filePath) => !isDefaultPageFile(filePath))
        .map(computePageId);
    return fileIds;
}
function computePageId(filePath) {
    const pageSuffix = '.page.';
    const pageId = (0, utils_1.slice)(filePath.split(pageSuffix), 0, -1).join(pageSuffix);
    (0, utils_1.assert)(!pageId.includes('\\'));
    return pageId;
}
function unique(arr) {
    return Array.from(new Set(arr));
}
function isDefaultPageFile(filePath) {
    (0, utils_1.assert)(!filePath.includes('\\'));
    if (!filePath.includes('/_default')) {
        return false;
    }
    (0, utils_1.assertUsage)(filePath.includes('_default.page.client.') || filePath.includes('_default.page.server.'), `\`_default.*\` file should be either \`_default.page.client.*\` or \`_default.page.server.*\` but we got: ${filePath}`);
    return true;
}
function resolveRouteString(pageRouteFileExports, urlPathname, pageRouteFilePath) {
    const routeString = pageRouteFileExports.default;
    (0, utils_1.assert)(typeof pageRouteFilePath === 'string');
    (0, utils_1.assertUsage)(routeString.startsWith('/'), `A Route String should start with a leading \`/\` but \`${pageRouteFilePath}\` has \`export default '${routeString}'\`. Make sure to \`export default '/${routeString}'\` instead.`);
    return routeWith_pathToRegexp(urlPathname, routeString);
}
async function resolveRouteFunction(pageRouteFileExports, urlPathname, pageContext, pageRouteFilePath) {
    const routeFunction = pageRouteFileExports.default;
    let result = routeFunction({ url: urlPathname, pageContext });
    (0, utils_1.assertUsage)(!(0, utils_1.isPromise)(result) || pageRouteFileExports.iKnowThePerformanceRisksOfAsyncRouteFunctions, `The Route Function ${pageRouteFilePath} returned a promise. Async Route Functions may significantly slow down your app: every time a page is rendered the Route Functions of *all* your pages are called and awaited for. A slow Route Function will slow down all your pages. If you still want to define an async Route Function then \`export const iKnowThePerformanceRisksOfAsyncRouteFunctions = true\` in \`${pageRouteFilePath}\`.`);
    result = await result;
    if ([true, false].includes(result)) {
        result = { match: result };
    }
    (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(result), `The Route Function ${pageRouteFilePath} should return a boolean or a plain JavaScript object, instead it returns \`${result && result.constructor}\`.`);
    if (!(0, utils_1.hasProp)(result, 'match')) {
        result['match'] = true;
    }
    (0, utils_1.assert)((0, utils_1.hasProp)(result, 'match'));
    (0, utils_1.assertUsage)(typeof result.match === 'boolean' || typeof result.match === 'number', `The \`match\` value returned by the Route Function ${pageRouteFilePath} should be a boolean or a number.`);
    assertRouteParams(result, `The \`routeParams\` object returned by the Route Function ${pageRouteFilePath} should`);
    const routeParams = result.routeParams || {};
    Object.keys(result).forEach((key) => {
        (0, utils_1.assertUsage)(key === 'match' || key === 'routeParams', `The Route Function ${pageRouteFilePath} returned an object with an unknown key \`{ ${key} }\`. Allowed keys: ['match', 'routeParams'].`);
    });
    (0, utils_1.assert)((0, utils_1.isPlainObject)(routeParams));
    return {
        matchValue: result.match,
        routeParams
    };
}
function assertRouteParams(result, errPrefix) {
    (0, utils_1.assert)(errPrefix.endsWith(' should'));
    if (!(0, utils_1.hasProp)(result, 'routeParams')) {
        return;
    }
    (0, utils_1.assertUsage)((0, utils_1.isPlainObject)(result.routeParams), `${errPrefix} be a plain JavaScript object.`);
    (0, utils_1.assertUsage)(Object.values(result.routeParams).every((val) => typeof val === 'string'), `${errPrefix} only hold string values.`);
}
async function loadPageRoutes(globalContext) {
    let onBeforeRouteHook = null;
    const filesystemRoots = [];
    const defaultPageRouteFiles = (0, getPageFiles_1.findDefaultFiles)(globalContext._allPageFiles['.page.route']);
    await Promise.all(defaultPageRouteFiles.map(async ({ filePath, loadFile }) => {
        const fileExports = await loadFile();
        assertExportsOfDefaulteRoutePage(fileExports, filePath);
        if ('onBeforeRoute' in fileExports) {
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'onBeforeRoute', 'function'), `The \`onBeforeRoute\` export of \`${filePath}\` should be a function.`);
            const { onBeforeRoute } = fileExports;
            onBeforeRouteHook = { filePath, onBeforeRoute };
        }
        if ('filesystemRoutingRoot' in fileExports) {
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'filesystemRoutingRoot', 'string'), `The \`filesystemRoutingRoot\` export of \`${filePath}\` should be a string.`);
            filesystemRoots.push({
                rootPath: dirname(filePath),
                rootValue: fileExports.filesystemRoutingRoot
            });
        }
    }));
    const allPageIds = globalContext._allPageIds;
    const pageRoutes = [];
    await Promise.all(allPageIds
        .filter((pageId) => !isErrorPage(pageId))
        .map(async (pageId) => {
        const filesystemRoute = getFilesystemRoute(pageId, filesystemRoots);
        (0, utils_1.assert)(filesystemRoute.startsWith('/'));
        (0, utils_1.assert)(!filesystemRoute.endsWith('/') || filesystemRoute === '/');
        const pageRoute = {
            pageId,
            filesystemRoute
        };
        const pageRouteFile = (0, getPageFiles_1.findPageFile)(globalContext._allPageFiles['.page.route'], pageId);
        if (pageRouteFile) {
            const { filePath, loadFile } = pageRouteFile;
            const fileExports = await loadFile();
            assertExportsOfRoutePage(fileExports, filePath);
            (0, utils_1.assertUsage)('default' in fileExports, `${filePath} should have a default export.`);
            (0, utils_1.assertUsage)((0, utils_1.hasProp)(fileExports, 'default', 'string') || (0, utils_1.hasProp)(fileExports, 'default', 'function'), `The default export of ${filePath} should be a string or a function.`);
            (0, utils_1.assertUsage)(!('iKnowThePerformanceRisksOfAsyncRouteFunctions' in fileExports) ||
                (0, utils_1.hasProp)(fileExports, 'iKnowThePerformanceRisksOfAsyncRouteFunctions', 'boolean'), `The export \`iKnowThePerformanceRisksOfAsyncRouteFunctions\` of ${filePath} should be a boolean.`);
            const routeValue = fileExports.default;
            (0, utils_1.objectAssign)(pageRoute, {
                pageRouteFile: { filePath, fileExports, routeValue }
            });
            pageRoutes.push(pageRoute);
        }
        else {
            pageRoutes.push(pageRoute);
        }
    }));
    return { pageRoutes, onBeforeRouteHook };
}
exports.loadPageRoutes = loadPageRoutes;
function isReservedPageId(pageId) {
    (0, utils_1.assert)(!pageId.includes('\\'));
    return pageId.includes('/_');
}
function isErrorPage(pageId) {
    (0, utils_1.assert)(!pageId.includes('\\'));
    return pageId.includes('/_error');
}
exports.isErrorPage = isErrorPage;
function dirname(filePath) {
    (0, utils_1.assert)(filePath.startsWith('/'));
    (0, utils_1.assert)(!filePath.endsWith('/'));
    const paths = filePath.split('/');
    const dirPath = (0, utils_1.slice)(paths, 0, -1).join('/');
    (0, utils_1.assert)(dirPath.startsWith('/'));
    (0, utils_1.assert)(!dirPath.endsWith('/') || dirPath === '/');
    return dirPath;
}
function assertExportsOfRoutePage(fileExports, filePath) {
    (0, utils_1.assertExports)(fileExports, filePath, ['default', 'iKnowThePerformanceRisksOfAsyncRouteFunctions']);
}
function assertExportsOfDefaulteRoutePage(fileExports, filePath) {
    (0, utils_1.assertExports)(fileExports, filePath, ['onBeforeRoute', 'filesystemRoutingRoot'], {
        ['_onBeforeRoute']: 'onBeforeRoute'
    });
}
//# sourceMappingURL=route.js.map