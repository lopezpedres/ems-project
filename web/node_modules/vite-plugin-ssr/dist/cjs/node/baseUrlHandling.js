"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertBaseUrl = exports.prependBaseUrl = exports.analyzeBaseUrl = void 0;
const utils_1 = require("../shared/utils");
const ssrEnv_1 = require("./ssrEnv");
// Possible Base URL values:
// `base: '/some-nested-path/'`
// `base: 'http://another-origin.example.org/'`
// `base: './'` (WIP: not supported yet)
function assertBaseUrl(baseUrl, userErrorMessagePrefix) {
    if (!userErrorMessagePrefix) {
        (0, utils_1.assert)(baseUrl.startsWith('/') || baseUrl.startsWith('http'));
        return;
    }
    (0, utils_1.assertUsage)(baseUrl.startsWith('/') || baseUrl.startsWith('http') || baseUrl.startsWith('./'), userErrorMessagePrefix + 'Wrong `base` value `' + baseUrl + '`; `base` should start with `/`, `./`, or `http`.');
    (0, utils_1.assertUsage)(!baseUrl.startsWith('./'), 'Relative Base URLs are not supported yet (`baseUrl` that starts with `./`). Open a new GitHub ticket so we can discuss adding support for your use case.');
}
exports.assertBaseUrl = assertBaseUrl;
function analyzeBaseUrl(url_) {
    // Unmutable
    const urlPristine = url_;
    // Mutable
    let url = url_;
    (0, utils_1.assert)(url.startsWith('/') || url.startsWith('http'));
    const baseUrl = getBaseUrl();
    (0, utils_1.assert)(baseUrl.startsWith('/') || baseUrl.startsWith('http'));
    if (baseUrl === '/') {
        return { urlWithoutBaseUrl: urlPristine, hasBaseUrl: true };
    }
    const { urlWithoutOrigin, urlOrigin } = (0, utils_1.handleUrlOrigin)(url);
    let urlOriginHasBeenRemoved = false;
    {
        const baseUrlOrigin = (0, utils_1.handleUrlOrigin)(baseUrl).urlOrigin;
        const baseUrlHasOrigin = baseUrlOrigin !== null;
        let urlHasOrigin = urlOrigin !== null;
        (0, utils_1.assertUsage)(!baseUrlHasOrigin || urlHasOrigin, `You provided a \`baseUrl\` (\`${baseUrl}\`) that contains a URL origin (\`${baseUrlOrigin}\`) but the \`pageContext.url\` (\`${url}\`) you provided in your server middleware (\`const renderPage = createPageRenderer(/*...*/); renderPage(pageContext);\`) does not contain a URL origin. Either remove the URL origin from your \`baseUrl\` or make sure to always provide the URL origin in \`pageContext.url\`.`);
        if (urlHasOrigin && !baseUrlHasOrigin) {
            urlOriginHasBeenRemoved = true;
            url = urlWithoutOrigin;
            urlHasOrigin = false;
        }
        (0, utils_1.assert)(urlHasOrigin === baseUrlHasOrigin);
    }
    if (!url.startsWith(baseUrl)) {
        return { urlWithoutBaseUrl: urlPristine, hasBaseUrl: false };
    }
    (0, utils_1.assert)(url.startsWith('/') || url.startsWith('http'));
    url = url.slice(baseUrl.length);
    /* url can actually start with `httpsome-pathname`
    assert(!url.startsWith('http'))
    */
    /* `handleUrlOrigin('some-pathname-without-leading-slash')` fails
    assert((handleUrlOrigin(url).urlOrigin===null))
    */
    if (!url.startsWith('/'))
        url = '/' + url;
    (0, utils_1.assert)(url.startsWith('/'));
    if (urlOriginHasBeenRemoved) {
        (0, utils_1.assert)(urlOrigin !== null);
        (0, utils_1.assert)(urlOrigin.startsWith('http'));
        (0, utils_1.assert)(url.startsWith('/'));
        url = (0, utils_1.addUrlOrigin)(url, urlOrigin);
        (0, utils_1.assert)(url.startsWith('http'));
    }
    return { urlWithoutBaseUrl: url, hasBaseUrl: true };
}
exports.analyzeBaseUrl = analyzeBaseUrl;
function prependBaseUrl(url) {
    let baseUrl = getBaseUrl();
    // Probably safer to remove the origin; `prependBaseUrl()` is used when injecting static assets in HTML;
    // origin is useless in static asset URLs, while the origin causes trouble upon `https`/`http` mismatch.
    baseUrl = (0, utils_1.handleUrlOrigin)(baseUrl).urlWithoutOrigin;
    if (baseUrl === '/')
        return url;
    if (baseUrl.endsWith('/')) {
        baseUrl = (0, utils_1.slice)(baseUrl, 0, -1);
    }
    // We can and should expect `baseUrl` to not contain `/` doublets. (We cannot expect url to not contain `/` doublets.)
    (0, utils_1.assert)(!baseUrl.endsWith('/'));
    (0, utils_1.assert)(url.startsWith('/'));
    return `${baseUrl}${url}`;
}
exports.prependBaseUrl = prependBaseUrl;
function getBaseUrl() {
    const { baseUrl } = (0, ssrEnv_1.getSsrEnv)();
    assertBaseUrl(baseUrl);
    return baseUrl;
}
//# sourceMappingURL=baseUrlHandling.js.map