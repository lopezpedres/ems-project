"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPageAssets = exports.injectAssets_internal = exports.injectAssets = void 0;
const utils_1 = require("../../shared/utils");
const getPreloadTags_1 = require("../getPreloadTags");
const ssrEnv_1 = require("../ssrEnv");
const getViteManifest_1 = require("../getViteManifest");
const baseUrlHandling_1 = require("../baseUrlHandling");
const _devalue = require("devalue");
const path_1 = require("path");
const inferMediaType_1 = require("./inferMediaType");
const devalue = _devalue;
async function getPageAssets(pageContext, dependencies, pageClientFilePath, isPreRendering) {
    (0, utils_1.assert)(dependencies.every((filePath) => (0, path_1.isAbsolute)(filePath)));
    const { isProduction = false } = (0, ssrEnv_1.getSsrEnv)();
    let clientManifest = null;
    let serverManifest = null;
    if (isPreRendering || isProduction) {
        const manifests = retrieveViteManifest(isPreRendering);
        clientManifest = manifests.clientManifest;
        serverManifest = manifests.serverManifest;
    }
    const preloadAssets = await (0, getPreloadTags_1.getPreloadUrls)(pageContext, dependencies, clientManifest, serverManifest);
    let pageAssets = preloadAssets.map((src) => {
        const { mediaType = null, preloadType = null } = (0, inferMediaType_1.inferMediaType)(src) || {};
        const assetType = mediaType === 'text/css' ? 'style' : 'preload';
        return {
            src,
            assetType,
            mediaType,
            preloadType
        };
    });
    const scriptSrc = !isProduction ? pageClientFilePath : resolveScriptSrc(pageClientFilePath, clientManifest);
    pageAssets.push({
        src: scriptSrc,
        assetType: 'script',
        mediaType: 'text/javascript',
        preloadType: null
    });
    pageAssets = pageAssets.map((pageAsset) => {
        pageAsset.src = (0, baseUrlHandling_1.prependBaseUrl)((0, utils_1.normalizePath)(pageAsset.src));
        return pageAsset;
    });
    sortPageAssetsForHttpPush(pageAssets);
    return pageAssets;
}
exports.getPageAssets = getPageAssets;
function sortPageAssetsForHttpPush(pageAssets) {
    pageAssets.sort((0, utils_1.higherFirst)(({ assetType, preloadType }) => {
        let priority = 0;
        // CSS has highest priority
        if (assetType === 'style')
            return priority;
        priority--;
        if (preloadType === 'style')
            return priority;
        priority--;
        // Visual assets have high priority
        if (preloadType === 'font')
            return priority;
        priority--;
        if (preloadType === 'image')
            return priority;
        priority--;
        // JavaScript has lowest priority
        if (preloadType === 'script')
            return priority - 1;
        if (assetType === 'script')
            return priority - 2;
        return priority;
    }));
}
function retrieveViteManifest(isPreRendering) {
    const { clientManifest, serverManifest, clientManifestPath, serverManifestPath } = (0, getViteManifest_1.getViteManifest)();
    const userOperation = isPreRendering
        ? 'running `$ vite-plugin-ssr prerender`'
        : 'running the server with `isProduction: true`';
    (0, utils_1.assertUsage)(clientManifest && serverManifest, 'You are ' +
        userOperation +
        " but you didn't build your app yet: make sure to run `$ vite build && vite build --ssr` before. (Following build manifest is missing: `" +
        clientManifestPath +
        '` and/or `' +
        serverManifestPath +
        '`.)');
    return { clientManifest, serverManifest };
}
async function injectAssets(htmlString, pageContext) {
    (0, utils_1.assertUsage)(typeof htmlString === 'string', '[injectAssets(htmlString, pageContext)]: Argument `htmlString` should be a string.');
    (0, utils_1.assertUsage)(pageContext, '[injectAssets(htmlString, pageContext)]: Argument `pageContext` is missing.');
    const errMsg = (body) => '[injectAssets(htmlString, pageContext)]: ' +
        body +
        '. Make sure that `pageContext` is the object that `vite-plugin-ssr` provided to your `render(pageContext)` hook.';
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, 'urlNormalized', 'string'), errMsg('`pageContext.urlNormalized` should be a string'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_pageId', 'string'), errMsg('`pageContext._pageId` should be a string'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_pageContextClient', 'object'), errMsg('`pageContext._pageContextClient` is missing'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_pageAssets'), errMsg('`pageContext._pageAssets` is missing'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_pageFilePath', 'string'), errMsg('`pageContext._pageFilePath` is missing'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_passToClient', 'string[]'), errMsg('`pageContext._passToClient` is missing'));
    (0, utils_1.assertUsage)((0, utils_1.hasProp)(pageContext, '_pageClientPath', 'string'), errMsg('`pageContext._pageClientPath` is missing'));
    (0, utils_1.castProp)(pageContext, '_pageAssets');
    pageContext._pageAssets;
    htmlString = await injectAssets_internal(htmlString, pageContext);
    return htmlString;
}
exports.injectAssets = injectAssets;
async function injectAssets_internal(htmlString, pageContext) {
    (0, utils_1.assert)(htmlString);
    (0, utils_1.assert)(typeof htmlString === 'string');
    // Inject Vite transformations
    const { urlNormalized } = pageContext;
    (0, utils_1.assert)(typeof urlNormalized === 'string');
    htmlString = await applyViteHtmlTransform(htmlString, urlNormalized);
    // Inject pageContext__client
    (0, utils_1.assertUsage)(!injectPageInfoAlreadyDone(htmlString), 'Assets are being injected twice into your HTML. Make sure to remove your superfluous `injectAssets()` call (`vite-plugin-ssr` already automatically calls `injectAssets()`).');
    htmlString = injectPageInfo(htmlString, pageContext);
    // Inject script
    const scripts = pageContext._pageAssets.filter(({ assetType }) => assetType === 'script');
    (0, utils_1.assert)(scripts.length === 1);
    const script = scripts[0];
    (0, utils_1.assert)(script);
    htmlString = injectScript(htmlString, script);
    // Inject preload links
    const preloadAssets = pageContext._pageAssets.filter(({ assetType }) => assetType === 'preload' || assetType === 'style');
    const linkTags = preloadAssets.map((pageAsset) => {
        const isEsModule = pageAsset.preloadType === 'script';
        return inferAssetTag(pageAsset, isEsModule);
    });
    htmlString = injectLinkTags(htmlString, linkTags);
    return htmlString;
}
exports.injectAssets_internal = injectAssets_internal;
async function applyViteHtmlTransform(htmlString, urlNormalized) {
    const ssrEnv = (0, ssrEnv_1.getSsrEnv)();
    if (ssrEnv.isProduction) {
        return htmlString;
    }
    htmlString = await ssrEnv.viteDevServer.transformIndexHtml(urlNormalized, htmlString);
    return htmlString;
}
function resolveScriptSrc(filePath, clientManifest) {
    (0, utils_1.assert)(filePath.startsWith('/'));
    (0, utils_1.assert)((0, ssrEnv_1.getSsrEnv)().isProduction);
    const manifestKey = filePath.slice(1);
    const manifestVal = clientManifest[manifestKey];
    (0, utils_1.assert)(manifestVal);
    (0, utils_1.assert)(manifestVal.isEntry);
    let { file } = manifestVal;
    (0, utils_1.assert)(!file.startsWith('/'));
    return '/' + file;
}
const pageInfoInjectionBegin = '<script>window.__vite_plugin_ssr__pageContext';
function injectPageInfo(htmlString, pageContext) {
    (0, utils_1.assert)(pageContext._pageContextClient['_pageId']);
    (0, utils_1.assert)(pageContext._pageContextClient['_pageId'] === pageContext._pageId);
    const pageContextSerialized = serializePageContext(pageContext);
    const injection = `${pageInfoInjectionBegin} = ${pageContextSerialized}</script>`;
    return injectEnd(htmlString, injection);
}
function injectPageInfoAlreadyDone(htmlString) {
    return htmlString.includes(pageInfoInjectionBegin);
}
function serializePageContext(pageContext) {
    let pageContextSerialized;
    try {
        pageContextSerialized = devalue(pageContext._pageContextClient);
    }
    catch (err) {
        pageContext._passToClient.forEach((prop) => {
            try {
                devalue(pageContext[prop]);
            }
            catch (err) {
                console.error(err);
                (0, utils_1.assertUsage)(false, `\`pageContext['${prop}']\` can not be serialized and therefore not passed to the client. Either remove \`'${prop}'\` from \`passToClient\` or make sure that \`pageContext['${prop}']\` is serializable. The \`devalue\` serialization error is shown above (serialization is done with https://github.com/Rich-Harris/devalue).`);
            }
        });
        console.error(err);
        (0, utils_1.assert)(false);
    }
    return pageContextSerialized;
}
function injectScript(htmlString, script) {
    const isEsModule = true;
    const injection = inferAssetTag(script, isEsModule);
    return injectEnd(htmlString, injection);
}
function injectLinkTags(htmlString, linkTags) {
    (0, utils_1.assert)(linkTags.every((tag) => tag.startsWith('<') && tag.endsWith('>')));
    const injection = linkTags.join('');
    return injectBegin(htmlString, injection);
}
function injectBegin(htmlString, injection) {
    const headOpen = /<head[^>]*>/;
    if (headOpen.test(htmlString)) {
        return injectAtOpeningTag(htmlString, headOpen, injection);
    }
    const htmlBegin = /<html[^>]*>/;
    if (htmlBegin.test(htmlString)) {
        return injectAtOpeningTag(htmlString, htmlBegin, injection);
    }
    if (htmlString.toLowerCase().startsWith('<!doctype')) {
        const lines = htmlString.split('\n');
        return [...(0, utils_1.slice)(lines, 0, 1), injection, ...(0, utils_1.slice)(lines, 1, 0)].join('\n');
    }
    else {
        return injection + '\n' + htmlString;
    }
}
function injectEnd(htmlString, injection) {
    const bodyClose = '</body>';
    if (htmlString.includes(bodyClose)) {
        return injectAtClosingTag(htmlString, bodyClose, injection);
    }
    const htmlClose = '</html>';
    if (htmlString.includes(htmlClose)) {
        return injectAtClosingTag(htmlString, htmlClose, injection);
    }
    return htmlString + '\n' + injection;
}
function injectAtOpeningTag(htmlString, openingTag, injection) {
    const matches = htmlString.match(openingTag);
    (0, utils_1.assert)(matches && matches.length >= 1);
    const tag = matches[0];
    (0, utils_1.assert)(tag);
    const htmlParts = htmlString.split(tag);
    (0, utils_1.assert)(htmlParts.length >= 2);
    // Insert `injection` after first `tag`
    const before = (0, utils_1.slice)(htmlParts, 0, 1);
    const after = (0, utils_1.slice)(htmlParts, 1, 0).join(tag);
    return before + tag + injection + after;
}
function injectAtClosingTag(htmlString, closingTag, injection) {
    (0, utils_1.assert)(closingTag.startsWith('</'));
    (0, utils_1.assert)(closingTag.endsWith('>'));
    (0, utils_1.assert)(!closingTag.includes(' '));
    const htmlParts = htmlString.split(closingTag);
    (0, utils_1.assert)(htmlParts.length >= 2);
    // Insert `injection` before last `closingTag`
    const before = (0, utils_1.slice)(htmlParts, 0, -1).join(closingTag);
    const after = (0, utils_1.slice)(htmlParts, -1, 0);
    return before + injection + closingTag + after;
}
function inferAssetTag(pageAsset, isEsModule) {
    const { src, assetType, mediaType, preloadType } = pageAsset;
    (0, utils_1.assert)(isEsModule === false || assetType === 'script' || preloadType === 'script');
    if (assetType === 'script') {
        (0, utils_1.assert)(mediaType === 'text/javascript');
        if (isEsModule) {
            return `<script type="module" src="${src}"></script>`;
        }
        else {
            return `<script src="${src}"></script>`;
        }
    }
    if (assetType === 'style') {
        // CSS has utmost priority.
        // Would there be any advantage of using a preload tag for a css file instead of loading it right away?
        return `<link rel="stylesheet" type="text/css" href="${src}">`;
    }
    if (assetType === 'preload') {
        if (preloadType === 'font') {
            // `crossorigin` is needed for fonts, see https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types/preload#cors-enabled_fetches
            return `<link rel="preload" as="font" crossorigin type="${mediaType}" href="${src}">`;
        }
        if (preloadType === 'script') {
            (0, utils_1.assert)(mediaType === 'text/javascript');
            if (isEsModule) {
                return `<link rel="modulepreload" as="script" type="${mediaType}" href="${src}">`;
            }
            else {
                return `<link rel="preload" as="script" type="${mediaType}" href="${src}">`;
            }
        }
        const attributeAs = !preloadType ? '' : ` as="${preloadType}"`;
        const attributeType = !mediaType ? '' : ` type="${mediaType}"`;
        return `<link rel="preload" href="${src}"${attributeAs}${attributeType}>`;
    }
    (0, utils_1.assert)(false);
}
//# sourceMappingURL=injectAssets.js.map